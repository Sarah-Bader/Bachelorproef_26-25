\chapter{\IfLanguageName{dutch}{Literatuurstudie}{State of the art}}%
\label{ch:literatuurstudie}

%-----------------------------

\section{De mainframeindustrie}

Voor een lange tijd werd beweerd dat de mainframecomputer zou uitsterven en dat grote bedrijven er afstand van zouden doen \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}. Het einde van mainframes is nog steeds niet gekomen en in sommige sectoren is er zelfs sprake van een trend om te blijven investeren in mainframes \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}.  

Het onderzoek van \textcite{Sagers_Ball_Hosack_Twitchell_Wallace_2018} toont aan dat er een behoefte is aan een voorturende werkracht met mainframe-kennis. Mainframes bekleden nog steeds een belangrijken rol in bedrijven en dat zal waarschijnlijk nog tientallen jaren zo blijven. Ook wordt vermeld dat de academische wereld niet in staat is om voldoende mensen met mainframe-kennis op te leiden. Dit komt omdat de opleiding in het verleden zijn stopgezet. Uit het onderzoek blijkt dat het aantal nieuwe medewerkers dat de industrie nodig heeft als gevolg van pensionering, groter is dan het aantal mensen dat wordt opgeleid door de academische wereld \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}. 

Het onderzoek van \textcite{Sagers_Ball_Hosack_Twitchell_Wallace_2018} wordt ondersteund door recent onderzoek waarin wordt geconstateerd dat een mainframe voor grote IT-bedrijven nog steeds een belangrijke functie vervult. De mainframecomputer heeft daarbij ook nieuwe mogelijkheden gekregen die het aantrekkelijk maken voor nieuwe kopers. Het vermogen van mainframes om de fundamentele bedrijfsprocessen voor banken en verzekeringsmaatschappijen te waarborgen, samen met de nieuwe mogelijkheden die het de afgelopen jaren heeft gekregen, zorgen ervoor dat mainframes relevant blijven \autocite{shaik_2024}.

In het onderzoek van \textcite{waites_ketterer_2013} wordt het punt herhaald dat de werknemers die mainframes ontwikkelen, ondersteunen en onderhouden bijna met pensioen gaan en daarmee hun waardevolle kennis verdwijnt.


\section{Aanwezigheid van HLASM-code}

Door de nauwkeurigheid, flexibiliteit en efficiëntie van HLASM, blijft het een essentieël component in mainframe-omgevingen \autocite{yalamanchili_2022}. Het zorgt ervoor dat systeemontwikkelaars toegang hebben tot geheugen en het kunnen manipuleren. In hogere programmeertalen zoals COBOL, zijn deze functionaliteiten beperkt. HLASM wordt dus gebruikt binnen een context waar prestatie centraal staat, hierdoor blijft het een belangrijk component \autocite{yalamanchili_2022}. 

\subsection{HLASM onderhoud en modernisatie}

Het onderzoek van \autocite{ehrman_2004} geeft advies over het beheer van legacy-applicaties op mainframes. Legacy betekent niet meteen dat het aan vervanging toe is, code wordt als legacy benoemt wanneer het de productie ingaat. Het wordt vaak negatief bekeken omdat het een bron kan zijn van problemen en onderhoud \autocite{ehrman_2004}. 

Applicaties moderniseren en onderhouden is een mogelijkheid die grote voordelen en lagere kosten kan bieden \autocite{ehrman_2004}. Het legacy-systeem kan gezien worden als een investering die je hergebruikt. Ook heeft het minder nood aan nieuwe testen, sinds de code minder wordt veranderd integenstelling tot een volledige conversie \autocite{ehrman_2004}.  

Nieuwe tools kunnen helpen met het moderniseren van HLASM-applicaties \autocite{ehrman_2004}. Ze kunen meer inzicht geven in het gedrag van applicaties. Het moderniseren van HLASM kan stapsgewijs aangepakt worden: afzonderlijke instructies, blokken
code, procedures, modules... De organisatie kiest zelf hoe groot of klein deze stappen zijn en per stap kunnen de nodige testen uitgevoerd worden \autocite{ehrman_2004}. 

\subsubsection{High Level Assembler Toolkit Feature}

De High Level Assembler Toolkit Feature is een IBM-product dat een set van tools bevat om het herstel en de ontwikkeling van HLASM applicaties te verbeteren, analyseren, debuggen en te onderhouden \autocite{ehrman_2001}. Hierdoor helpt het bij de modernisatie van HLASM-applicaties \autocite{ehrman_2004}.  

\subsubsection{FermaT}

%Een bestaande tool die kan worden gebruikt voor de visualisatie van HLASM-code is FermaT. Deze tool is vooral gericht op het begrijpen en migreren van legacycode. Het is een zeer krachtige en zware tool die veel functionaliteiten heeft \autocite{ward_2001}.

%Ook bied IBM een HLASM parser aan, die onderdeel maakt van IBM Developer for z/OS. Deze parser is bedoeld voor diepe analyse en gebruik met andere tools \autocite{ibm_hlasm_parser}.

\subsubsection{Tape-z}

%https://github.com/avishek-sen-gupta/tape-z

%\section{Bestaande visualisatietools en parsers}


%Het doel van dit onderzoek is het ontwikkelen van een lichte tool die HLASM-code omzet naar een high-level control-flowdiagram visualisatie in Mermaid.js-syntax. Deze tool is specifiek bedoeld voor educatieve doeleinden, om beginnende ontwikkelaars te ondersteunen. Ook ligt de focus enkel op een beperkte subset van control-flow-instructies, in tegenstelling tot bestaande tools.


%\section{Herimplementatie vs Herbouw}

%Uit onderzoek naar herimplementatie als alternatief van herontwikkeling voor een verouderd systeem, blijkt dat het een realistisch alternatief is maar vooral wanneer een geautomatiseerde conversie niet mogelijk is. In de besproken casestudy's leverde herimplementatie bruikbare resultaten die duurzamer leken dan de herontwikkelingresultaten. Herimplementatie is vooral zinvol wanneer een legacy-systeem essentieel is voor de onderneming en als het nog jarenlang moet meegaan \autocite{sneed_verhoef_2019}. 


\subsection{Kosten van Onderhoud}

% ----

In het onderzoek van \textcite{xia_bao_lo_xing_hassan_li_2018} werd een grootschalig veldonderzoek gedaan naar hoe programmacomprehensie in de praktijk wordt uitgevoerd. Er werd gekeken naar 79 ontwikkelaars die aan 7 industriële projecten werkten. Als resultaat werd geconstateerd dat ontwikkelaars gemiddeld tot ~58\% van hun tijd besteden aan het begrijpen van programma's. Hierbij gebruiken ze vaak webbrowsers en documentatie editors. Ook werd vastgelegd dat senior ontwikkelaars minder tijd besteden aan het begrijpen van programma's en dat er meer tijd nodig voor is tijdens een onderhoudsfase \autocite{xia_bao_lo_xing_hassan_li_2018}. 

% ----

\section{Moeilijkheden voor beginnende ontwikkelaars}

Uit het onderzoek van \textcite{feigenspan_kästner_liebig_apel_hanenberg_2012} blijkt dat binnen een groep bachelorstudenten 


Assemblytalen zijn zeer gedetailleerd, als ontwikkelaar definieer je elke kleine stap van het programma, wat ingewikkeld kan zijn voor beginners. Uit onderzoek blijkt dat naarmate de ervaring toeneemt, het gemakkelijker wordt om de functionaliteit van code te begrijpen \autocite{feigenspan_kästner_liebig_apel_hanenberg_2012}.

Binnen het onderwijs hebben studenten vooral moeite met de componenten die de logische volgorde van het programma bepalen. Dit zijn de componenten die de control flow van het programma definiëren. Bij het begrijpen van de control flow maken beginners vaak fouten en ervaren ze vaak verwarring \autocite{kawash_2024}. Hieruit kan worden geconcludeerd dat de control flow van code een moeilijkheid is onder beginnende ontwikkelaars.

\section{Effectiviteit van visualisatietechnieken}

Visualisatietechnieken worden vaak gebruikt om code beter te begrijpen en worden ook erkend als technieken die sneller en meer inzicht geven in codefunctionaliteiten. Visualisaties worden vaak gebruikt om de structuur van code te representeren \autocite{storey_2005}. Bij assemblytalen kan visualisatie vooral helpen, aangezien de code vaak is opgebouwd uit zeer gedetailleerde instructies en kan worden gegroepeerd in componenten \autocite{baldwin_myers_storey_coady_2009}.




\section{JavaScript Parsing}

Binnen HLASM wordt er gewerkt met een vaste kolom-gebaseerde indeling. Elk onderdeel van de code staat op een vaste plek. Elke kolom heeft een eigen functie: kolommen 1-8 zijn voor labels, kolommen 10-14 voor de instructie en vanaf kolom 16 staan de operanden. Na kolom 71 wordt alles beschouwd als commentaar of wordt het genegeerd \autocite{ibm_hlasm}. 

JavaScript is zeer nuttig om tekst te parsen, het is namelijk erg goed in het doorzoeken en herkennen van patronen \autocite{flanagan_2020}. Voor de PoC is een regel-voor-regel aanpak voldoende. Hierbij zal de parser elke regel doorlopen op basis van de vaste kolomposities. Zo kunnen de labels en instructies herkend worden die bijdragen aan de control-flow. De verzamelde elementen worden vervolgens gemapt naar Mermaid.js-elementen.

\section{Mermaid.js en flowcharts}

Met Mermaid.js worden flowcharts en andere structuren vanuit tekst automatisch gevisualiseerd \autocite{sveidqvist_jain_2021}. Dit maakt het makkelijk om een mapping te maken van HLASM-elementen naar een visuele representatie. Het gebruik van flowcharts om complexe software begrijpelijk te maken is een bekend middel in de informatica \autocite{ensmenger_2016}. 

Een flowchart maakt gebruik van blokken en pijlen om een route te definiëren. In de context van informatica worden flowcharts vaak gebruikt om de route van een programma weer te geven \autocite{charntaweekhun_Wangsiripitak_2006}. In het geval van HLASM kunnen bijvoorbeeld spronginstructies worden weergegeven als pijlen die het programma brengen naar een ander codeblok.

%-----------------------------

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

%Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

%\begin{figure}
  %\centering
  %\includegraphics[width=0.8\textwidth]{grail.jpg}
  %\caption[Voorbeeld figuur.]{\label{fig:grail}Voorbeeld van invoegen van een figuur. Zorg altijd voor een uitgebreid bijschrift dat de figuur volledig beschrijft zonder in de tekst te moeten gaan zoeken. Vergeet ook je bronvermelding niet!}
%\end{figure}

%\begin{listing}
  %\begin{minted}{python}
    %import pandas as pd
    %import seaborn as sns

    %penguins = sns.load_dataset('penguins')
    %sns.relplot(data=penguins, x="flipper_length_mm", y="bill_length_mm", hue="species")
  %\end{minted}
  %\caption[Voorbeeld codefragment]{Voorbeeld van het invoegen van een codefragment.}
%\end{listing}

%\lipsum[7-20]

%\begin{table}
  %\centering
  %\begin{tabular}{lcr}
    %\toprule
    %\textbf{Kolom 1} & \textbf{Kolom 2} & \textbf{Kolom 3} \\
    %$\alpha$         & $\beta$          & $\gamma$         \\
    %\midrule
   % A                & 10.230           & a                \\
   % B                & 45.678           & b                \\
   % C                & 99.987           & c                \\
    %\bottomrule
  %\end{tabular}
  %\caption[Voorbeeld tabel]{\label{tab:example}Voorbeeld van een tabel.}
%\end{table}

