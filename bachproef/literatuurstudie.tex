\chapter{\IfLanguageName{dutch}{Literatuurstudie}{State of the art}}%
\label{ch:literatuurstudie}

%-----------------------------

\section{De mainframeindustrie}

Voor een lange tijd werd beweerd dat de mainframecomputer zou uitsterven en dat grote bedrijven er afstand van zouden doen \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}. Het einde van mainframes is nog steeds niet gekomen en in sommige sectoren is er zelfs sprake van een trend om te blijven investeren in mainframes \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}.  

Het onderzoek van \textcite{Sagers_Ball_Hosack_Twitchell_Wallace_2018} toont aan dat er een behoefte is aan een voorturende werkracht met mainframe-kennis. Mainframes bekleden nog steeds een belangrijken rol in bedrijven en dat zal waarschijnlijk nog tientallen jaren zo blijven. Ook wordt vermeld dat de academische wereld niet in staat is om voldoende mensen met mainframe-kennis op te leiden. Dit komt omdat de opleiding in het verleden zijn stopgezet. Uit het onderzoek blijkt dat het aantal nieuwe medewerkers dat de industrie nodig heeft als gevolg van pensionering, groter is dan het aantal mensen dat wordt opgeleid door de academische wereld \autocite{Sagers_Ball_Hosack_Twitchell_Wallace_2018}. 

Het onderzoek van \textcite{Sagers_Ball_Hosack_Twitchell_Wallace_2018} wordt ondersteund door recent onderzoek waarin wordt geconstateerd dat een mainframe voor grote IT-bedrijven nog steeds een belangrijke functie vervult. De mainframecomputer heeft daarbij ook nieuwe mogelijkheden gekregen die het aantrekkelijk maken voor nieuwe kopers. Het vermogen van mainframes om de fundamentele bedrijfsprocessen voor banken en verzekeringsmaatschappijen te waarborgen, samen met de nieuwe mogelijkheden die het de afgelopen jaren heeft gekregen, zorgen ervoor dat mainframes relevant blijven \autocite{shaik_2024}.

In het onderzoek van \textcite{waites_ketterer_2013} wordt het punt herhaald dat de werknemers die mainframes ontwikkelen, ondersteunen en onderhouden bijna met pensioen gaan en daarmee hun waardevolle kennis verdwijnt.


\section{Aanwezigheid van HLASM-code}

Door de nauwkeurigheid, flexibiliteit en efficiëntie van HLASM, blijft het een essentieël component in mainframe-omgevingen \autocite{yalamanchili_2022}. Het zorgt ervoor dat systeemontwikkelaars toegang hebben tot geheugen en het kunnen manipuleren. In hogere programmeertalen zoals COBOL, zijn deze functionaliteiten beperkt. HLASM wordt dus gebruikt binnen een context waar prestatie centraal staat, hierdoor blijft het een belangrijk component \autocite{yalamanchili_2022}. 

\subsection{HLASM Onderhoud en Modernisatie}

Het onderzoek van \autocite{ehrman_2004} geeft advies over het beheer van legacy-applicaties op mainframes. Legacy betekent niet meteen dat het aan vervanging toe is, code wordt als legacy benoemt wanneer het de productie ingaat. Het wordt vaak negatief bekeken omdat het een bron kan zijn van problemen en onderhoud \autocite{ehrman_2004}. 

Applicaties moderniseren en onderhouden is een mogelijkheid die grote voordelen en lagere kosten kan bieden \autocite{ehrman_2004}. Het legacy-systeem kan gezien worden als een investering die je hergebruikt. Ook heeft het minder nood aan nieuwe testen, sinds de code minder wordt veranderd integenstelling tot een volledige conversie \autocite{ehrman_2004}.  

Nieuwe tools kunnen helpen met het moderniseren van HLASM-applicaties \autocite{ehrman_2004}. Ze kunen meer inzicht geven in het gedrag van applicaties. Het moderniseren van HLASM kan stapsgewijs aangepakt worden: afzonderlijke instructies, blokken
code, procedures, modules... De organisatie kiest zelf hoe groot of klein deze stappen zijn en per stap kunnen de nodige testen uitgevoerd worden \autocite{ehrman_2004}. 

\subsection{Bestaande HLASM-hulpmiddelen}

\subsubsection{High Level Assembler Toolkit Feature}

De High Level Assembler Toolkit Feature is een IBM-product dat een set van tools bevat om het herstel en de ontwikkeling van HLASM applicaties te verbeteren, analyseren, debuggen en te onderhouden \autocite{ehrman_2001}. Hierdoor helpt het bij de modernisatie van HLASM-applicaties \autocite{ehrman_2004}.  

\subsubsection{FermaT}

FermaT is een programma die kan gebruikt worden voor de visualisatie van HLASM-code. Het bestaat uit geïntegreerde tools voor programma-inzicht, migratie en herontwerp \autocite{ward_2001}. 

\subsubsection{Tape-z}

Tape/Z is een tookit ontworpen voor het analyseren en visualiseren van HLASM-code. Het doel van de tool is om code in kaart te brengen door middel van het parsen van instructies en het bouwen van control-flow diagrammen \autocite{gupta_2025}. 

%https://github.com/avishek-sen-gupta/tape-z


\subsection{Kosten van Onderhoud}

% ----

In het onderzoek van \textcite{xia_bao_lo_xing_hassan_li_2018} werd een grootschalig veldonderzoek gedaan naar hoe programmacomprehensie in de praktijk wordt uitgevoerd. Er werd gekeken naar 79 ontwikkelaars die aan 7 industriële projecten werkten. Als resultaat werd geconstateerd dat ontwikkelaars gemiddeld tot ~58\% van hun tijd besteden aan het begrijpen van programma's. Hierbij gebruiken ze vaak webbrowsers en documentatie editors. Ook werd vastgelegd dat senior ontwikkelaars minder tijd besteden aan het begrijpen van programma's en dat er meer tijd nodig voor is tijdens een onderhoudsfase \autocite{xia_bao_lo_xing_hassan_li_2018}. 

% ----

\section{Moeilijkheden voor Beginnende Ontwikkelaars}

Assemblytalen zijn zeer gedetailleerd, als ontwikkelaar definieer je elke kleine stap van het programma, wat ingewikkeld kan zijn voor beginners. Uit onderzoek blijkt dat naarmate de ervaring toeneemt, het gemakkelijker wordt om de functionaliteit van code te begrijpen \autocite{feigenspan_kästner_liebig_apel_hanenberg_2012}.

Binnen het onderwijs hebben studenten vooral moeite met de componenten die de logische volgorde van het programma bepalen. Dit zijn de componenten die de control flow van het programma definiëren. Bij het begrijpen van de control flow maken beginners vaak fouten en ervaren ze vaak verwarring \autocite{kawash_2024}. 

\section{Grafische Softwarevisualisatie}

%Visualisatietechnieken worden vaak gebruikt om code beter te begrijpen en worden ook erkend als technieken die sneller en meer inzicht geven in codefunctionaliteiten. Visualisaties worden vaak gebruikt om de structuur van code te representeren \autocite{storey_2005}. Bij assemblytalen kan visualisatie vooral helpen, aangezien de code vaak is opgebouwd uit zeer gedetailleerde instructies en kan worden gegroepeerd in componenten \autocite{baldwin_myers_storey_coady_2009}.

In het onderzoek van \textcite{cárdenas_aponte_2017} werd een gecontroleerd experiment uitgevoerd om de impact van het gebruik van grafische visualisatietechnieken bij het begrijpen van software vast te leggen. Hiervoor werden tajen uitgevoerd door 20 studenten, de helft gebruike een visualisatietool, de andere helft niet. Er werd beordeeld op de voltooiingstijd en de nauwkeurigheid van de antwoorden. 

Uit het onderzoek werd geconcludeerd dat het gebruik van garfische visualisatie de juistheid verhoogt met 21,45\%. Er was geen bewijs dat er een vermindering was van voltooiingstijd. Grafische visualisatietechnieken kunnen dus bijdragen aan het begrijpen van programma's \autocite{cárdenas_aponte_2017}.  

\subsection{Control-Flow Grafieken}

Een control-flow grafiek heeft knooppunten die overeenkomen met basisblokken code met elk een gerichte rand die een mogelijke controlestroom tussen twee knooppunten aangeeft \autocite{debbabi_salcic_biglari-abhari_malik}. Hierdoor is het mogelijk om alle uitvoeringspaden van een programma te analyseren. Ze zijn vooral heel nuttig voor statische analyse en om inzicht te verkrijgen in de structuur van een programma \autocite{debbabi_salcic_biglari-abhari_malik}. 

%\subsection{HLASM visualisatie}
%Het onderzoek van \textcite{baldwin_myers_storey_coady_2009} 

\subsection{Mermaid.js}

Mermaid.js is een open-source tool waarmee diagrammen en flowcharts worden opgesteld vanuit tekst. Het heeft een simpele syntax die het makkelijk maakt om visualisaties te maken. De tool wordt gebruikt voor documentatie, code-review en visuele uitleg \autocite{sveidqvist_jain_2021}. 


\section{JavaScript Parsing}

JavaScript is een geschikte programmeertaal om een parser mee te bouwen omdat het veel liberaries heeft en makkelijk integreert met webtechnologieën \autocite{mdn_contributors_2023}. Daardoor kan de parsinglogica gebruikt worden voor analyse en directe visualisatie in een webinterface. JavaScript heeft ook een brede community en documentatie die het makkelijker maken om een parser te ontwikkelen \autocite{mdn_contributors_2023}. 

\subsection{Chevrotain}

Chevrotain is een krachtige, open-source parsing library voor JavaScript \autocite{chevrotain_2018}. 


%-----------------------------

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

%Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

%\begin{figure}
  %\centering
  %\includegraphics[width=0.8\textwidth]{grail.jpg}
  %\caption[Voorbeeld figuur.]{\label{fig:grail}Voorbeeld van invoegen van een figuur. Zorg altijd voor een uitgebreid bijschrift dat de figuur volledig beschrijft zonder in de tekst te moeten gaan zoeken. Vergeet ook je bronvermelding niet!}
%\end{figure}

%\begin{listing}
  %\begin{minted}{python}
    %import pandas as pd
    %import seaborn as sns

    %penguins = sns.load_dataset('penguins')
    %sns.relplot(data=penguins, x="flipper_length_mm", y="bill_length_mm", hue="species")
  %\end{minted}
  %\caption[Voorbeeld codefragment]{Voorbeeld van het invoegen van een codefragment.}
%\end{listing}

%\lipsum[7-20]

%\begin{table}
  %\centering
  %\begin{tabular}{lcr}
    %\toprule
    %\textbf{Kolom 1} & \textbf{Kolom 2} & \textbf{Kolom 3} \\
    %$\alpha$         & $\beta$          & $\gamma$         \\
    %\midrule
   % A                & 10.230           & a                \\
   % B                & 45.678           & b                \\
   % C                & 99.987           & c                \\
    %\bottomrule
  %\end{tabular}
  %\caption[Voorbeeld tabel]{\label{tab:example}Voorbeeld van een tabel.}
%\end{table}

